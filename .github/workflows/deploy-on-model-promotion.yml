name: Deploy on Model Promotion

# Trigger when model is promoted to Production in MLflow via webhook
on:
  repository_dispatch:
    types: [model-promoted]
  # Fallback: Manual trigger
  workflow_dispatch:
    inputs:
      model_name:
        description: 'Model name (e.g., yolov8-detector)'
        required: true
        default: 'simple-cnn-demo'
      model_version:
        description: 'Model version to deploy'
        required: false
      namespace:
        description: 'Kubernetes namespace'
        required: false
        default: 'production'

concurrency:
  group: deployment
  cancel-in-progress: false

env:
  REGISTRY_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  REGISTRY_USERNAME: ${{ secrets.ACR_USERNAME }}
  IMAGE_NAME: inference-service
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  NAMESPACE: production

jobs:
  extract-model-info:
    name: Extract Model Information
    runs-on: ubuntu-latest
    outputs:
      model_name: ${{ steps.model-info.outputs.model_name }}
      model_version: ${{ steps.model-info.outputs.model_version }}
      image_tag: ${{ steps.model-info.outputs.image_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install mlflow

      - name: Extract model information from webhook
        id: model-info
        env:
          WEBHOOK_PAYLOAD: ${{ toJson(github.event.client_payload) }}
          MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
        run: python scripts/extract_model_info.py
        continue-on-error: false

      - name: Display model information
        run: |
          echo "Model Name: ${{ steps.model-info.outputs.model_name }}"
          echo "Model Version: ${{ steps.model-info.outputs.model_version }}"
          echo "Image Tag: ${{ steps.model-info.outputs.image_tag }}"

  validate-model:
    name: Validate Model
    runs-on: ubuntu-latest
    needs: extract-model-info
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install mlflow

      - name: Validate model exists and is in Production stage
        env:
          MODEL_NAME: ${{ needs.extract-model-info.outputs.model_name }}
          MODEL_VERSION: ${{ needs.extract-model-info.outputs.model_version }}
          MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
        run: |
          python << 'EOF'
          import mlflow
          import os
          import sys
          
          model_name = os.getenv('MODEL_NAME')
          model_version = os.getenv('MODEL_VERSION')
          
          mlflow.set_tracking_uri(os.getenv('MLFLOW_TRACKING_URI'))
          client = mlflow.tracking.MlflowClient()
          
          try:
              # Get latest Production model
              versions = client.get_latest_versions(model_name, stages=['Production'])
              if not versions:
                  print(f"❌ No Production model found for {model_name}")
                  sys.exit(1)
              
              prod_version = versions[0]
              print(f"✓ Production model found: {model_name} v{prod_version.version}")
              print(f"  Status: {prod_version.status}")
              print(f"  Created: {prod_version.creation_timestamp}")
              
              if prod_version.status != 'READY':
                  print(f"⚠ Warning: Model status is {prod_version.status}, not READY")
                  
          except Exception as e:
              print(f"❌ Error validating model: {e}")
              sys.exit(1)
          EOF

  build-and-push-image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [extract-model-info, validate-model]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.extract-model-info.outputs.image_tag }}
            ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:latest
          labels: |
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.version=${{ needs.extract-model-info.outputs.image_tag }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

      - name: Image build summary
        run: |
          echo "## Docker Image Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.extract-model-info.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_STEP_SUMMARY

  deploy-to-aks:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: [extract-model-info, build-and-push-image]
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Verify Kubernetes connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Check deployment exists
        run: |
          if ! kubectl get deployment inference-service -n ${{ env.NAMESPACE }}; then
            echo "❌ Deployment not found in namespace ${{ env.NAMESPACE }}"
            echo "Creating deployment from template..."
            kubectl apply -f k8s/deployment.yaml -n ${{ env.NAMESPACE }}
          else
            echo "✓ Deployment exists"
          fi

      - name: Update deployment image
        run: |
          kubectl set image deployment/inference-service \
            inference-service=${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.extract-model-info.outputs.image_tag }} \
            -n ${{ env.NAMESPACE }}
          
          echo "✓ Image updated to: ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.extract-model-info.outputs.image_tag }}"

      - name: Update environment variables
        run: |
          kubectl set env deployment/inference-service \
            MODEL_NAME=${{ needs.extract-model-info.outputs.model_name }} \
            MODEL_VERSION=${{ needs.extract-model-info.outputs.model_version }} \
            MLFLOW_TRACKING_URI=${{ secrets.MLFLOW_TRACKING_URI }} \
            -n ${{ env.NAMESPACE }}
          
          echo "✓ Environment variables updated"

      - name: Wait for rollout
        timeout-minutes: 10
        run: |
          echo "Waiting for deployment rollout..."
          kubectl rollout status deployment/inference-service \
            -n ${{ env.NAMESPACE }} \
            --timeout=10m
          
          echo "✓ Rollout completed"

      - name: Wait for pod readiness
        timeout-minutes: 5
        run: |
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app=inference-service \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s
          
          echo "✓ All pods are ready"

      - name: Get deployment info
        if: always()
        run: |
          echo "## Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get deployment inference-service -n ${{ env.NAMESPACE }} -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=inference-service -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Verify health endpoint
        timeout-minutes: 2
        run: |
          # Get service endpoint
          SERVICE_IP=$(kubectl get service inference-service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          if [ "$SERVICE_IP" = "pending" ]; then
            echo "Load balancer IP still pending, checking via port-forward..."
            kubectl port-forward svc/inference-service 8000:8000 -n ${{ env.NAMESPACE }} &
            PF_PID=$!
            sleep 5
            HEALTH_URL="http://localhost:8000/health"
          else
            HEALTH_URL="http://$SERVICE_IP:8000/health"
          fi
          
          echo "Health check URL: $HEALTH_URL"
          for i in {1..30}; do
            if curl -sf "$HEALTH_URL"; then
              echo "✓ Health check passed"
              kill $PF_PID 2>/dev/null || true
              exit 0
            fi
            echo "Attempt $i/30..."
            sleep 2
          done
          
          echo "❌ Health check failed after 30 attempts"
          kill $PF_PID 2>/dev/null || true
          exit 1

  test-deployed-model:
    name: Test Deployed Model
    runs-on: ubuntu-latest
    needs: [extract-model-info, deploy-to-aks]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests numpy pillow

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Port-forward to service
        run: |
          kubectl port-forward svc/inference-service 8000:8000 -n ${{ env.NAMESPACE }} &
          sleep 5

      - name: Run test predictions
        env:
          MODEL_NAME: ${{ needs.extract-model-info.outputs.model_name }}
        run: |
          python << 'EOF'
          import requests
          import numpy as np
          import time
          
          url = "http://localhost:8000/predict"
          
          # Create test input (28x28 grayscale image for MNIST-like models)
          test_data = np.random.rand(1, 1, 28, 28).astype(np.float32)
          
          print("Running test predictions...")
          for i in range(5):
              try:
                  response = requests.post(
                      url,
                      json={"data": test_data.tolist()},
                      timeout=10
                  )
                  
                  if response.status_code == 200:
                      result = response.json()
                      print(f"✓ Prediction {i+1} successful: {result}")
                  else:
                      print(f"⚠ Prediction {i+1} returned status {response.status_code}: {response.text}")
                      
              except Exception as e:
                  print(f"❌ Prediction {i+1} failed: {e}")
                  time.sleep(1)
          EOF

  on-success:
    name: Deployment Success Notification
    runs-on: ubuntu-latest
    needs: [extract-model-info, test-deployed-model]
    if: success()
    steps:
      - name: Create success summary
        run: |
          echo "## ✓ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Model **${{ needs.extract-model-info.outputs.model_name }}** v${{ needs.extract-model-info.outputs.model_version }} has been successfully deployed to AKS." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: production" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ secrets.ACR_LOGIN_SERVER }}/inference-service:${{ needs.extract-model-info.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_STEP_SUMMARY

  on-failure:
    name: Deployment Failure Rollback
    runs-on: ubuntu-latest
    needs: [extract-model-info, deploy-to-aks]
    if: failure()
    steps:
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Rollback deployment
        run: |
          echo "Rolling back to previous deployment..."
          kubectl rollout undo deployment/inference-service -n production
          kubectl rollout status deployment/inference-service -n production --timeout=5m
          echo "✓ Rollback completed"

      - name: Create failure summary
        run: |
          echo "## ❌ Deployment Failed - Rolled Back" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Deployment of ${{ needs.extract-model-info.outputs.model_name }} v${{ needs.extract-model-info.outputs.model_version }} failed." >> $GITHUB_STEP_SUMMARY
          echo "The deployment has been automatically rolled back to the previous version." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Review logs for details and resolve issues before retrying.**" >> $GITHUB_STEP_SUMMARY
